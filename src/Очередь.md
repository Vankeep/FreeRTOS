## Пример 1. Две задачи пишут в очередь

```cpp
#include <Arduino.h>
#include <STM32FreeRTOS.h>
HardwareSerial uartPort(PA10, PA9);

xQueueHandle xQueue; 

void senderTask1( void *pvParameters ) {
    long lValueToSend = 1000;
    portBASE_TYPE xStatus;  
    while (1) {
        lValueToSend++;
        xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );
        if( xStatus != pdPASS ){
            uartPort.println("senderTask1: Could not send to the queue");
        }
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

void senderTask2( void *pvParameters ) {
    long lValueToSend = 2000;
    portBASE_TYPE xStatus;  
    while (1) {
        lValueToSend++;
        xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );
        if( xStatus != pdPASS ){
            uartPort.println("senderTask2: Could not send to the queue");
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

/**
 * Поведение:
 * 1. Проверяет, пуста ли очередь (uxQueueMessagesWaiting == 0).
 * 2. Если очередь неожиданно пуста - выводит предупреждение.
 * 3. Ожидает данные в течение 100 мс.
 * 4. При успешном приёме выводит значение, иначе сообщение об ошибке.
 */
void receiverTask(void *pvParameters) {
    long lReceivedValue;          // Буфер для принимаемых данных
    portBASE_TYPE xStatus;        // Статус операции с очередью
    const portTickType xTicksToWait = 100 / portTICK_RATE_MS;  // Таймаут в тиках (100 мс)

    while(1) {
        // Проверка перед операцией приёма, что очередь содержит данные 
        if(uxQueueMessagesWaiting(xQueue) == 0) {
            uartPort.println("Queue should have been empty!");  // Очередь пустая
            // vTaskDelay(pdMS_TO_TICKS(300)); // ЕСЛИ РАССКОМЕНТИРОВАТЬ ТО БУДЕТ СИТУЦИЯ КОГДА ДАННЫЕ ТЕРЯЮТСЯ
        }

        /* Прием данных из очереди.
        * xQueue -  определяет очередь, из которой данные будут прочитаны.
        *   Очередь была создана перед запуском шедулера, и поэтому перед тем,
        *   как эта задача запустится в первый раз.
        *
        * &lReceivedValue - адрес буфера, в который принятые данные будут
        *   помещены. В нашем случае здесь просто указан адрес переменной,
        *   которая имеет нужный размер, чтобы удержать в себе принятые данные.
        * 
        * xTicksToWait время блокировки – максимальное время, в котором
        *   задача должна оставаться в состоянии Blocked, ожидая появления
        *   данных на очереди. Здесь используется константа portTICK_RATE_MS
        *   для преобразования 100 миллисекунд во время, указанное в тиках. */
        xStatus = xQueueReceive(xQueue, &lReceivedValue, xTicksToWait);

        // Обработка результата получения данных
        if(xStatus == pdPASS) {
            uartPort.printf("Received = %d\r\n", lReceivedValue);  // Успешный приём
        } else {
            uartPort.println("Could not receive from the queue.");  // Ошибка приёма
        }
    }
}

void setup(){
    uartPort.begin(115200);

    xQueue = xQueueCreate( 5, sizeof(long));
    if(xQueue != NULL){
        xTaskCreate(senderTask1, "Sender1", 1000, NULL, 1, NULL);
        xTaskCreate(senderTask2, "Sender2", 1000, NULL, 1, NULL); 

        xTaskCreate(receiverTask, "Receiver", 1000, NULL, 2, NULL);

        vTaskStartScheduler();
    } else {
        /* Очередь не может быть создана. */
    }
}

void loop(){}

```

### Serial
```
...
Received = 1042
Queue should have been empty!
Received = 2022
Queue should have been empty!
Received = 1043
Queue should have been empty!
...
```
