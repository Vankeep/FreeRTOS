

### Объяснение стека и кучи в FreeRTOS

В FreeRTOS (как и в большинстве ОС) память делится на две ключевые области: **стек (stack)** и **куча (heap)**. Они имеют разное назначение и поведение. Давайте разберем подробно.

---

### 1. Стек (Stack)

#### Что это?
Стек — это **специальная область памяти**, выделяемая **для каждой задачи индивидуально**. Он используется для:
- Хранения локальных переменных задачи
- Сохранения адресов возврата при вызове функций
- Передачи параметров в функции
- Сохранения контекста процессора при переключении задач

#### Ключевые особенности:
1. **Выделение при создании задачи**:
   ```cpp
   xTaskCreate(
     vTaskFunction,    // Функция задачи
     "TaskName",       // Имя
     128,              // Размер стека в СЛОВАХ (не байтах!)
     NULL,             // Параметры
     1,                // Приоритет
     &xHandle          // Хэндл задачи
   );
   ```
   - Размер указывается в **словах** (обычно 4 байта для 32-битных STM32)
   - Пример: 128 слов = 128 * 4 = 512 байт

2. **Рост сверху вниз**:
   - Стек растет от старших адресов к младшим
   - Указатель стека (SP) перемещается вниз при записи данных

3. **Переполнение стека (Stack Overflow)**:
   - Самая опасная ошибка в FreeRTOS!
   - Происходит, когда задача использует больше стека, чем выделено
   - Последствия: повреждение данных других задач, сбои ОС

#### Как контролировать?
FreeRTOS предоставляет механизм для отслеживания:
```cpp
// Получить минимальный свободный стек (в словах) с момента запуска задачи
UBaseType_t freeStack = uxTaskGetStackHighWaterMark(xTaskHandle);
```
- Возвращает **наименьший** объем свободного стека за все время работы
- Если значение близко к 0 — риск переполнения!

---

### 2. Куча (Heap)

#### Что это?
Куча — **общая область памяти**, используемая FreeRTOS для:
- Создания задач (`xTaskCreate`)
- Создания очередей, семафоров, мьютексов
- Выделения памяти под буферы
- Внутренних нужд ОС

#### Ключевые особенности:
1. **Единая для всей системы**:
   - Все задачи и объекты делят одну кучу
   - Размер задается в `FreeRTOSConfig.h`:
     ```c
     #define configTOTAL_HEAP_SIZE (1024 * 4) // 4KB
     ```

2. **Управляется аллокатором памяти**:
   FreeRTOS поддерживает 5 реализаций (`heap_1.c` ... `heap_5.c`):
   - **heap_1**: Простейший, память только выделяется (не освобождается)
   - **heap_2**: Позволяет освобождать память, но не дефрагментирует
   - **heap_3**: Обертка над стандартным malloc/free (требует поддержки)
   - **heap_4**: Поддерживает дефрагментацию (рекомендуется для STM32)
   - **heap_5**: Работает с несколькими несмежными областями памяти

3. **Фрагментация памяти**:
   - Проблема при частом выделении/освобождении
   - Может привести к ситуации "память есть, но выделить нельзя"

#### Как контролировать?
```cpp
// Получить текущий свободный объем кучи (в байтах)
size_t freeHeap = xPortGetFreeHeapSize();

// Детальная статистика (для heap_4 и heap_5)
HeapStats_t heapStats;
vPortGetHeapStats(&heapStats);
```

---

### 3. Сравнение стека и кучи

| Характеристика       | Стек (Stack)                          | Куча (Heap)                          |
|----------------------|---------------------------------------|--------------------------------------|
| **Назначение**       | Локальные данные задачи               | Динамическое выделение под объекты   |
| **Выделение**        | При создании задачи (фиксированный размер) | По запросу (переменный размер)       |
| **Освобождение**     | Автоматически при удалении задачи     | Явно (через `vTaskDelete()`, `vQueueDelete()` и т.д.) |
| **Скорость**         | Очень высокая (просто смещение SP)    | Медленнее (поиск свободного блока)   |
| **Риск переполнения**| Да (критично!)                        | Нет (возврат NULL при нехватке)      |
| **Контроль**         | `uxTaskGetStackHighWaterMark()`       | `xPortGetFreeHeapSize()`             |

---

### 4. Практические рекомендации для STM32

#### Для стека:
1. **Определяйте размер эмпирически**:
   - Начните с 128-256 слов (512-1024 байт)
   - Используйте `uxTaskGetStackHighWaterMark()` для измерения реального использования
   - Добавьте 20-30% запаса

2. **Включите проверку переполнения**:
   ```c
   // В FreeRTOSConfig.h
   #define configCHECK_FOR_STACK_OVERFLOW 2
   ```
   FreeRTOS будет автоматически проверять целостность стека

#### Для кучи:
1. **Выбирайте правильный аллокатор**:
   - Для STM32 обычно **heap_4** (баланс скорости и функциональности)
   - Если нужно использовать внешнюю память — **heap_5**

2. **Моньте свободную память**:
   ```cpp
   void vApplicationMallocFailedHook() {
     // Обработчик нехватки памяти
     while(1); // Перезагрузка или диагностика
   }
   ```

3. **Избегайте динамического выделения в задачах**:
   - Лучше выделять память при инициализации
   - Используйте статическое создание объектов, где возможно

---

### 5. Пример диагностики памяти

```cpp
void monitorTask(void *pvParameters) {
  while(1) {
    // Статистика по задачам
    TaskStatus_t *taskArray = new TaskStatus_t[uxTaskGetNumberOfTasks()];
    UBaseType_t taskCount = uxTaskGetSystemState(taskArray, uxTaskGetNumberOfTasks(), NULL);
    
    Serial.println("\n=== Memory Report ===");
    
    for(int i = 0; i < taskCount; i++) {
      UBaseType_t stackFree = uxTaskGetStackHighWaterMark(taskArray[i].xHandle);
      Serial.printf("Task: %-15s Stack: %4u bytes free\n", 
                   taskArray[i].pcTaskName, 
                   stackFree * sizeof(StackType_t));
    }
    
    // Статистика по куче
    Serial.printf("Heap: %u bytes free\n", xPortGetFreeHeapSize());
    
    delete[] taskArray;
    vTaskDelay(pdMS_TO_TICKS(5000));
  }
}
```

---

### 6. Типичные ошибки и их решения

| Проблема                     | Причина                          | Решение                                     |
|------------------------------|----------------------------------|---------------------------------------------|
| Зависание системы            | Переполнение стека               | Увеличить размер стека, включить проверку   |
| Ошибка при создании задачи    | Нехватка памяти в куче           | Увеличить `configTOTAL_HEAP_SIZE`           |
| Система работает медленно    | Фрагментация кучи                | Использовать heap_4, пересмотреть алгоритмы |
| Случайные сбои               | Повреждение памяти               | Проверить выравнивание данных, использовать `configASSERT` |

---

### Заключение

- **Стек** — это личная память каждой задачи. Его размер должен быть достаточным для всех операций, но не избыточным.
- **Куча** — общая ресурсная область системы. Ее размер должен покрывать все динамические потребности.
- **Мониторинг** обоих типов памяти критически важен для стабильной работы системы на STM32.
- Всегда тестируйте систему при максимальной нагрузке, чтобы выявить проблемы с памятью на этапе разработки.